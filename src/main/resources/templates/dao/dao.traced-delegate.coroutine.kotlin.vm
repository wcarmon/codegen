package $request.packageName.value

import ${entity.pkg.value}.${entity.name.upperCamel}
#if ($request.hasContextClass)
import $request.jvmContextClass
#end
#foreach ($importable in $entity.javaImportsForFields)
import $importable
#end
#foreach ($importable in $request.extraJVMImports)
import $importable
#end
import io.opentracing.Span
import io.opentracing.Tracer
import kotlin.coroutines.coroutineContext
import kotlinx.coroutines.withContext

import java.util.function.Function

private const val ENTITY_TYPE_NAME = "${entity.name.upperCamel}"

/**
 * OpenTracing based Traced DAO
 *
 * Uses Delegation pattern
 *
 * Relies on the Context class ($request.unqualifiedContextClass) to:
 * 1. provide the current [Span]
 * 2. build a new child Context, with a new [Span]
 *
 * Threadsafe & Reusable after construction
 */
@Suppress("TooManyFunctions")
class ${entity.name.upperCamel}TracedDAO(
  private val tracer: Tracer,

  /** Delegation Pattern: All DAO calls are delegated to this */
  private val realDAO: ${entity.name.upperCamel}DAO,

  /** Converts exception to a string for [io.opentracing.Span#setTag] */
  private val exceptionSerializer: Function<#[[Exception]]#, String>,

) : ${entity.name.upperCamel}DAO {

#if ($entity.hasPrimaryKeyFields)
  override suspend fun delete(${entity.kotlinMethodArgsForPKFields(false)}) {
    //TODO: kotlin preconditions on PK fields (see FieldValidation)

    val span = tracer.buildSpan("jdbc::delete")
      .asChildOf(coroutineContext[SpanElement]?.span)
      .ignoreActiveSpan()
      .withTag("entityType", ENTITY_TYPE_NAME)
      #foreach($pk in $entity.primaryKeyFields)
      .withTag("$pk.name.lowerCamel", ${pk.name.lowerCamel}.toString())
      #end
      .start()

    wrapDAOCall(span) {
      realDAO.delete($entity.commaSeparatedPKIdentifiers)
    }
  }

  override suspend fun exists(${entity.kotlinMethodArgsForPKFields(false)}): Boolean {
    //TODO: kotlin preconditions on PK fields (see FieldValidation)

    val span = tracer.buildSpan("jdbc::exists")
      .asChildOf(coroutineContext[SpanElement]?.span)
      .ignoreActiveSpan()
      .withTag("entityType", ENTITY_TYPE_NAME)
      #foreach($pk in $entity.primaryKeyFields)
      .withTag("$pk.name.lowerCamel", ${pk.name.lowerCamel}.toString())
      #end
      .start()

    return wrapDAOCall(span) {
      realDAO.exists($entity.commaSeparatedPKIdentifiers)
    }
  }

  override suspend fun findById(#if ($request.hasContextClass)#end ${entity.kotlinMethodArgsForPKFields(false)}): ${entity.name.upperCamel}? {
    //TODO: kotlin preconditions on PK fields (see FieldValidation)

    val span = tracer.buildSpan("jdbc::findById")
      .asChildOf(coroutineContext[SpanElement]?.span)
      .ignoreActiveSpan()
      .withTag("entityType", ENTITY_TYPE_NAME)
      #foreach($pk in $entity.primaryKeyFields)
      .withTag("$pk.name.lowerCamel", ${pk.name.lowerCamel}.toString())
      #end
      .start()

    return wrapDAOCall(span) {
      realDAO.findById($entity.commaSeparatedPKIdentifiers)
    }
  }
#end

  override suspend fun create(#if ($request.hasContextClass)#end entity: ${entity.name.upperCamel}) {
    val span = tracer.buildSpan("jdbc::create")
      .asChildOf(coroutineContext[SpanElement]?.span)
      .ignoreActiveSpan()
      .withTag("entityType", ENTITY_TYPE_NAME)
      #foreach($pk in $entity.primaryKeyFields)
      .withTag("$pk.name.lowerCamel", entity.${pk.name.lowerCamel}.toString())
      #end
      .start()

    wrapDAOCall(span) {
      realDAO.create(entity)
    }
  }

  override suspend fun list(#if ($request.hasContextClass)context: $request.unqualifiedContextClass#end): List<${entity.name.upperCamel}> {
    val span = tracer.buildSpan("jdbc::list")
        .asChildOf(coroutineContext[SpanElement]?.span)
        .ignoreActiveSpan()
        .withTag("entityType", ENTITY_TYPE_NAME)
        .start()

    return wrapDAOCall(span) {
      realDAO.list()
    }
  }

  override suspend fun update(#if ($request.hasContextClass)#end entity: ${entity.name.upperCamel}) {
    val span = tracer.buildSpan("jdbc::update")
        .asChildOf(coroutineContext[SpanElement]?.span)
        .ignoreActiveSpan()
        .withTag("entityType", ENTITY_TYPE_NAME)
        .start()

    wrapDAOCall(span) {
      realDAO.update(entity)
    }
  }

  override suspend fun upsert(#if ($request.hasContextClass)#end entity: ${entity.name.upperCamel}) {
    val span = tracer.buildSpan("jdbc::upsert")
        .asChildOf(coroutineContext[SpanElement]?.span)
        .ignoreActiveSpan()
        .withTag("entityType", ENTITY_TYPE_NAME)
        .start()

    wrapDAOCall(span) {
      realDAO.upsert(entity)
    }
  }

  // -- Patch methods
#foreach( $field in $entity.nonPrimaryKeyFields )
  override suspend fun set${field.name.upperCamel}(
    ${entity.kotlinMethodArgsForPKFields(false)},
    ${field.name.lowerCamel}: ${field.unqualifiedKotlinType}) {

    //TODO: '${field.name.lowerCamel}' field validation here (since not part of the POJO validation)

    val span = tracer.buildSpan("jdbc::patch")
      .asChildOf(coroutineContext[SpanElement]?.span)
      .ignoreActiveSpan()
      .withTag("entityType", ENTITY_TYPE_NAME)
      .withTag("fieldName", "$field.name.lowerCamel")
      .start()

    wrapDAOCall(span) {
      realDAO.set${field.name.upperCamel}($entity.commaSeparatedPKIdentifiers, ${field.name.lowerCamel})
    }
  }

#end

  /** Wrap the DAO call with proper span cleanup */
  private suspend fun <T> wrapDAOCall(span: Span, daoCall: suspend () -> T) =
    try {
      withContext(SpanElement(span)) {
        daoCall()
      }

    } catch (ex: Exception) {
      applyExceptionToSpan(span, ex)
      throw ex

    } finally {
      span.finish()
    }

  private fun applyExceptionToSpan(span: Span, ex: Exception) {
    span.setTag("error", true)
    span.setTag("error.kind", ex.javaClass.name)
    span.setTag("error.object", exceptionSerializer.apply(ex))
  }
}
