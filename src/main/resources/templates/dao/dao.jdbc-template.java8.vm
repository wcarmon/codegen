package $request.packageName.value;

#if ($request.hasContextClass)
import $request.jvmContextClass;
#end
import ${entity.pkg.value}.${entity.name.upperCamel};
#foreach ($importable in $entity.javaImportsForFields)
import $importable;
#end
import org.springframework.jdbc.core.JdbcTemplate;
#foreach ($importable in $request.extraJVMImports)
import $importable;
#end
import org.springframework.jdbc.core.RowMapper;

import java.time.*;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/**
 * DAO implementation for {@link ${entity.pkg.value}.${entity.name.upperCamel}}.
 * <p>
 * Uses {@link org.springframework.jdbc.core.JdbcTemplate} to execute queries.
 * <p>
 * Uses {@link java.sql.PreparedStatement}
 * <p>
 * See https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html
 * <p>
 * Threadsafe & Reusable after construction
 */
public final class ${entity.name.upperCamel}DAOImpl implements ${entity.name.upperCamel}DAO {

  private final JdbcTemplate jdbcTemplate;
  private final RowMapper<${entity.name.upperCamel}> rowMapper;

  public ${entity.name.upperCamel}DAOImpl(
    JdbcTemplate jdbcTemplate,
    RowMapper<${entity.name.upperCamel}> rowMapper){
    Objects.requireNonNull(jdbcTemplate, "jdbcTemplate is required and null");
    Objects.requireNonNull(rowMapper, "rowMapper is required and null");

    this.jdbcTemplate = jdbcTemplate;
    this.rowMapper = rowMapper;
  }

  #if ($entity.hasPrimaryKeyFields)
  @Override
  public void delete(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.javaMethodArgsForPKFields(false)} ) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    $entity.javaPrimaryKeyPreconditionStatements

    int affectedRowCount = jdbcTemplate.update(
      SQLQueries.DELETE__${entity.name.UpperSnake},
      ps -> {
        $entity.preparedStatementSetterStatementsForPK
      });
  }

  @Override
  public boolean exists(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.javaMethodArgsForPKFields(false)} ) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    $entity.javaPrimaryKeyPreconditionStatements

    Integer result = jdbcTemplate.queryForObject(
      SQLQueries.ROW_EXISTS__${entity.name.UpperSnake},
      Integer.class,
      $entity.jdbcSerializedPKFields);

    return result != null && result == 1;
  }

  @Override
  public ${entity.name.upperCamel} findById(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.javaMethodArgsForPKFields(false)} ) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    $entity.javaPrimaryKeyPreconditionStatements

    List<${entity.name.upperCamel}> results = jdbcTemplate.query(
        SQLQueries.SELECT_BY_PK__${entity.name.UpperSnake},
        ps -> {
          $entity.preparedStatementSetterStatementsForPK
        },
        rowMapper
      );

    if (null == results || results.isEmpty()) {
      return null;
    }

    if (results.size() > 1) {
      throw new IllegalStateException("Multiple rows match the PK: context=" + context + ", results=" + results);
    }

    return results.get(0);
  }
  #end

  @Override
  public void create(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.name.upperCamel} entity) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    Objects.requireNonNull(entity, "entity is required and null.");

    int affectedRowCount = jdbcTemplate.update(
      SQLQueries.INSERT__${entity.name.UpperSnake},
      ps -> {
        // TODO
      });

      //TODO: set the updated field  (field.isCreatedTimestamp)
      //TODO: set the created field (field.isCreatedTimestamp)
  }

  @Override
  public List<${entity.name.upperCamel}> list(#if ($request.hasContextClass)$request.unqualifiedContextClass context#end) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end

    //TODO: more here
  }

  @Override
  public void update(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.name.upperCamel} entity) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    Objects.requireNonNull(entity, "entity is required and null.");

    //TODO: set the updated field  (field.isCreatedTimestamp)

    int affectedRowCount = jdbcTemplate.update(
      SQLQueries.UPDATE__${entity.name.UpperSnake},
      ps -> {
        // TODO
      });
  }

  @Override
  public void upsert(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.name.upperCamel} entity) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    Objects.requireNonNull(entity, "entity is required and null.");

    //TODO: more here
    //TODO: set the updated field  (field.isCreatedTimestamp)
    //TODO: set the created field
  }
#foreach( $field in $entity.nonPrimaryKeyFields )
  @Override
  public void set${field.name.upperCamel}(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end
    ${entity.javaMethodArgsForPKFields(false)},
    ${field.unqualifiedJavaType} newValue) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    $entity.javaPrimaryKeyPreconditionStatements
    //TODO: requireNonNull precondition on ${field.unqualifiedJavaType} (except for primitives)

    //TODO: more here

    //TODO: set the updated field  (field.isCreatedTimestamp)
  }

#end
}
