package $request.packageName.value;

import ${entity.pkg.value}.${entity.name.upperCamel};
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
#if ($request.hasContextClass)
import $request.jvmContextClass;
#end
#foreach ($importable in $entity.javaImportsForFields)
import $importable;
#end
#foreach ($importable in $request.extraJVMImports)
import $importable;
#end
#if ($entity.requiresObjectWriter)
import com.fasterxml.jackson.databind.ObjectWriter;
#end

import java.sql.Types;
import java.time.*;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/**
 * DAO implementation for {@link ${entity.pkg.value}.${entity.name.upperCamel}}.
 * <p>
 * Uses {@link org.springframework.jdbc.core.JdbcTemplate} to execute queries.
 * <p>
 * Uses {@link java.sql.PreparedStatement}
 * <p>
 * See https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html
 * <p>
 * Threadsafe & Reusable after construction
 */
public final class ${entity.name.upperCamel}DAOImpl implements ${entity.name.upperCamel}DAO {

  private final JdbcTemplate jdbcTemplate;
  #if ($entity.requiresObjectWriter)
  /** To serialize collection fields */
  private final ObjectWriter objectWriter;
  #end
  private final RowMapper<${entity.name.upperCamel}> rowMapper;

  public ${entity.name.upperCamel}DAOImpl(
    JdbcTemplate jdbcTemplate,
    #if ($entity.requiresObjectWriter)
    ObjectWriter objectWriter,
    #end
    RowMapper<${entity.name.upperCamel}> rowMapper) {

    Objects.requireNonNull(jdbcTemplate, "jdbcTemplate is required and null");
    #if ($entity.requiresObjectWriter)
    Objects.requireNonNull(objectWriter, "objectWriter is required and null");
    #end
    Objects.requireNonNull(rowMapper, "rowMapper is required and null");

    this.jdbcTemplate = jdbcTemplate;
    #if ($entity.requiresObjectWriter)
    this.objectWriter = objectWriter;
    #end
    this.rowMapper = rowMapper;
  }

  #if ($entity.hasPrimaryKeyFields)
  @Override
  public void delete(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.javaMethodArgsForPKFields(false)} ) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    $entity.javaPrimaryKeyPreconditionStatements

    int affectedRowCount = jdbcTemplate.update(
      SQLQueries.DELETE__${entity.name.upperSnake},
      ps -> {
        $entity.javaPreparedStatementSetterStatementsForPK
      });
  }

  @Override
  public boolean exists(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.javaMethodArgsForPKFields(false)} ) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    $entity.javaPrimaryKeyPreconditionStatements

    Integer result = jdbcTemplate.queryForObject(
      SQLQueries.ROW_EXISTS__${entity.name.upperSnake},
      Integer.class,
      $entity.jdbcSerializedPKFields);

    return null != result  && 1 == result;
  }

  @Override
  public ${entity.name.upperCamel} findById(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.javaMethodArgsForPKFields(false)} ) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    $entity.javaPrimaryKeyPreconditionStatements

    List<${entity.name.upperCamel}> results = jdbcTemplate.query(
        SQLQueries.SELECT_BY_PK__${entity.name.upperSnake},
        ps -> {
          $entity.javaPreparedStatementSetterStatementsForPK
        },
        rowMapper);

    if (null == results || results.isEmpty()) {
      return null;
    }

    if (results.size() > 1) {
      //TODO: include PK arg(s)
      throw new IllegalStateException("Multiple rows match the PK: context=" + context + ", results=" + results);
    }

    return results.get(0);
  }
  #end

  @Override
  public void create(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.name.upperCamel} entity) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    Objects.requireNonNull(entity, "entity is required and null.");

    int affectedRowCount = jdbcTemplate.update(
      SQLQueries.INSERT__${entity.name.upperSnake},
      ps -> {
        try {
            $entity.javaInsertPreparedStatementSetterStatements

        } catch (Exception ex) {
          throw new RuntimeException("Failed to create ${entity.name.upperCamel}: " +
            "context=" + context +
            ", entity=" + entity,
            ex);
        }
    });
  }

  @Override
  public List<${entity.name.upperCamel}> list(#if ($request.hasContextClass)$request.unqualifiedContextClass context#end) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end

    return Collections.unmodifiableList(
      jdbcTemplate.query(
        SQLQueries.SELECT_ALL__${entity.name.upperSnake},
        rowMapper));
  }

  @Override
  public void update(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.name.upperCamel} entity) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    Objects.requireNonNull(entity, "entity is required and null.");

    int affectedRowCount = jdbcTemplate.update(
      SQLQueries.UPDATE__${entity.name.upperSnake},
      ps -> {
        try {
            $entity.javaUpdatePreparedStatementSetterStatements

        } catch (Exception ex) {
          throw new RuntimeException("Failed to update ${entity.name.upperCamel}: " +
            "context=" + context +
            ", entity=" + entity,
            ex);
        }
    });
  }

  @Override
  public void upsert(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end ${entity.name.upperCamel} entity) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    Objects.requireNonNull(entity, "entity is required and null.");

    //TODO: more here
    //TODO: set the updated field  (field.isCreatedTimestamp)
    //TODO: set the created field
  }

  // -- Patch methods
#foreach( $field in $entity.nonPrimaryKeyFields )
  @Override
  public void set${field.name.upperCamel}(#if ($request.hasContextClass)$request.unqualifiedContextClass context,#end
    ${entity.javaMethodArgsForPKFields(false)},
    ${field.unqualifiedJavaType} ${field.name.lowerCamel}) {
    #if($request.hasContextClass)
    Objects.requireNonNull(context, "context is required and null.");
    #end
    $entity.javaPrimaryKeyPreconditionStatements
    //TODO: requireNonNull precondition on ${field.unqualifiedJavaType} (except for primitives)
    //  field.type.nullable=$field.type.nullable

    //TODO: field validation here (since not part of the POJO validation)

    int affectedRowCount = jdbcTemplate.update(
      SQLQueries.PATCH__${entity.name.upperSnake}__${field.name.upperSnake},
      ps -> {
        try {
          $entity.javaUpdateFieldPreparedStatementSetterStatements($field)

        } catch (Exception ex) {
          throw new RuntimeException("Failed to patch ${entity.name.upperCamel}.${field.name.lowerCamel}: " +
            "context=" + context + ", value=" + ${field.name.lowerCamel},
            ex);
        }
    });
  }

#end
}
