package $request.packageName.value;

import ${entity.pkg}.${entity.name.upperCamel};
import org.springframework.jdbc.core.RowMapper;
#if ($entity.hasCollectionFields)import com.fasterxml.jackson.databind.ObjectMapper;#end
#if ($entity.hasCollectionFields)import com.fasterxml.jackson.core.type.TypeReference;#end

import java.io.*;
import java.math.*;
import java.net.*;
import java.nio.file.*;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.NClob;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.function.Function;

/**
 * Generated file
 *
 * Maps one row of ResultSet data to ${entity.name.upperCamel} instance
 *
 * See https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/RowMapper.html
 */
#if ($entity.hasCollectionFields)
@SuppressWarnings("unchecked")
#end
public final class ${entity.name.upperCamel}RowMapper implements RowMapper<${entity.name.upperCamel}> {

  #if ($entity.hasCollectionFields)
    #foreach ($field in $entity.collectionFields)
    private static final TypeReference<${field.jacksonTypeRef()}> ${field.name.upperSnake}_TYPE_REF =
      new TypeReference<>(){};
    #end

  private final ObjectMapper objectMapper;

  public ${entity.name.upperCamel}RowMapper(ObjectMapper objectMapper) {
    Objects.requireNonNull(objectMapper, "objectMapper is required")

    this.objectMapper = objectMapper;
  }
  #else
  public ${entity.name.upperCamel}RowMapper() {}
  #end

  /**
   * Maps $entity.fields.size()-fields from ResultSet
   *
   * @return ${entity.name.upperCamel} instance
   */
  @Override
  public ${entity.name.upperCamel} mapRow(ResultSet rs, int rowNum) throws SQLException {
    Objects.requireNonNull(rs, "null result set passed to ${entity.name.upperCamel}RowMapper");

    return ${entity.name.upperCamel}.builder()
        #if (!$entity.primaryKeyFields.isEmpty())
        // -- $entity.commentForPKFields
        #end
        #foreach( $field in $entity.primaryKeyFields )
          ## TODO: use the field.javaStringFactory
        .${field.name.lowerCamel}( ${field.type.rawTypeLiteral}.fromString(
          rs.${field.type.jdbcGetter()}("${field.name.lowerSnake}")))
        #end

        // -- Other Fields
        #foreach ($field in $entity.nonPrimaryKeyFields)
##
            ## -- Enums
            #if ($field.type.enumType)
            .${field.name.lowerCamel}( ${field.type.rawTypeLiteral}.fromString(
              rs.${field.type.jdbcGetter()}("${field.name.lowerSnake}")) )
##
            ## -- Collections
            #elseif ($field.type.base.isCollection())
            .${field.name.lowerCamel}(
                to${field.type.rawTypeLiteral}(
                rs.getString("${field.name.lowerSnake}"), ${field.name.upperSnake}_TYPE_REF))
##
            ## -- Temporal
            #elseif ($field.type.base.isTemporal())
            .${field.name.lowerCamel}( ${field.type.javaStringFactory()}(rs.getString("${field.name.lowerSnake}")))
##
##TODO: handle Path, URI & URL should use the temporal branch
            ## -- normal fields
            #else
            .${field.name.lowerCamel}( rs.${field.type.jdbcGetter()}("${field.name.lowerSnake}") )
            #end
        #end
    .build();
  }

  #if ($entity.hasCollectionFields)
  /**
   * Deserialize to a List
   *
   * @param serialized json version of list data
   * @param typeRef for compile time type safety
   * @param <L> complete type, (including the List)
   * @return a new List (possibly empty, never null)
   */
  private <L> L toList(String serialized, TypeReference<L> typeRef) {
    if( serialized == null || serialized.trim().isEmpty() ) {
      return (L) Collections.emptyList();
    }

    try {
      return objectMapper.readValue(serialized, typeRef);

    } catch (Exception ex) {
      throw new RuntimeException("Failed to deserialize List: serialized=" + serialized, ex);
    }
  }

  /**
   * Deserialize to a Set
   *
   * @param serialized json version of set data
   * @param typeRef for compile time type safety
   * @param <S> complete type, (including the Set)
   * @return a new Set (possibly empty, never null)
   */
  private <S> S toSet(String serialized, TypeReference<S> typeRef) {
    if( serialized == null || serialized.trim().isEmpty() ) {
      return (S) Collections.emptySet();
    }

    try {
      return objectMapper.readValue(serialized, typeRef);

    } catch (Exception ex) {
      throw new RuntimeException("Failed to deserialize Set: serialized=" + serialized, ex);
    }
  }
  #end
}
